Okay, here is an MVVM architectural breakdown for the QuickGen iOS application, focusing on module responsibilities rather than specific code implementation.

---

**QuickGen iOS Application - MVVM Architecture Design**

This document outlines the proposed MVVM (Model-View-ViewModel) structure for the QuickGen iOS application built with Swift and SwiftUI.

**1. Overview**

The application will be structured into three core layers according to the MVVM pattern: Model, View, and ViewModel. This separation aims to enhance testability, maintainability, and clarity of roles within the codebase. Data flow will primarily be unidirectional (View receives updates from ViewModel, View sends actions to ViewModel, ViewModel interacts with Model/Services). We will leverage SwiftUI's declarative nature and Combine for reactive data binding between View and ViewModel.

**2. Model Layer**

This layer represents the application's data and the logic for accessing and manipulating it. It is entirely independent of the UI.

*   **2.1. Data Structures (Entities):**
    *   `Workspace`: Represents a single H5 generation project. Contains properties like `id` (UUID), `name` (String), `creationDate` (Date), potentially `lastModifiedDate` (Date), and references or holds associated data (like chat history ID or latest H5 code ID).
    *   `ChatMessage`: Represents a single message in the workspace chat history. Contains properties like `id` (UUID), `workspaceId` (UUID), `sender` (Enum: `.user`, `.ai`), `content` (String), `timestamp` (Date).
    *   `GeneratedCode`: Represents the H5 code generated by the LLM for a specific workspace interaction. Contains `id` (UUID), `workspaceId` (UUID), `htmlContent` (String), `timestamp` (Date).
    *   `AppSettings`: Represents user-configurable settings. Contains properties like `appearance` (Enum: `.light`, `.dark`, `.system`), potentially `defaultExportFormat`, etc.

*   **2.2. Data Management & Services:**
    *   `WorkspaceDataManager` (Protocol & Implementation):
        *   **Responsibility:** Handles persistence (Create, Read, Update, Delete - CRUD) of `Workspace`, `ChatMessage`, and `GeneratedCode` data. This could use Core Data, Realm, File System storage, or other local persistence mechanisms.
        *   Provides methods like `fetchWorkspaces()`, `createWorkspace(name:)`, `saveChatMessage(_:toWorkspace:)`, `getLatestGeneratedCode(forWorkspace:)`, `deleteWorkspace(_:)`, `fetchChatHistory(forWorkspace:)`, `renameWorkspace(_:to:)`.
    *   `BFFService` (Protocol & Implementation):
        *   **Responsibility:** Handles all network communication with the Backend for Frontend (BFF). **Crucially, this is the ONLY module that interacts with the network backend.**
        *   Provides methods like `sendPrompt(prompt: String, workspaceId: UUID)` which returns the generated H5 code (`GeneratedCode` or just the String) or an error. Handles API requests, responses, and potential network errors. It does *not* know about the LLM directly, only about the BFF endpoints.
    *   `SettingsManager` (Protocol & Implementation):
        *   **Responsibility:** Handles persistence (Read, Write) of `AppSettings`. Typically uses `UserDefaults` or a dedicated settings file.
        *   Provides methods like `loadSettings()` and `saveSettings(_:)`.

**3. ViewModel Layer**

This layer acts as the bridge between the Model and the View. It prepares data from the Model for display in the View, holds UI-related state, and handles user actions received from the View by interacting with the Model layer (specifically the Data Management & Services). ViewModels are UI-framework-agnostic (no `import SwiftUI` or `import UIKit` if possible, except for potentially unavoidable data types like `Color` if absolutely necessary and conversion isn't practical elsewhere).

*   **3.1. `AppViewModel` (or `MainViewModel`):**
    *   **Responsibility:** Manages the overall application state, such as the currently selected/active workspace, the visibility state of the sidebar, and potentially global notifications or states. Coordinates transitions between major views (e.g., showing the `WorkspaceContentView` when a workspace is selected). It might hold references to child ViewModels or orchestrate their creation/data flow.
*   **3.2. `WelcomeViewModel`:**
    *   **Responsibility:** Handles logic for the Initial Welcome Screen. Exposes actions like `triggerNewWorkspaceCreation`, `triggerOpenRecentWorkspace`, `openDocumentation`. May hold a list of recent workspace identifiers fetched via `WorkspaceDataManager`.
*   **3.3. `SidebarViewModel`:**
    *   **Responsibility:** Manages the data and state for the SidebarView. Fetches and exposes lists of workspaces (e.g., `allWorkspaces`, `favoriteWorkspaces`, `exampleWorkspaces`) using `WorkspaceDataManager`. Handles search filtering logic. Processes user actions like selecting a workspace (notifying the `AppViewModel`), initiating the creation of a new workspace (potentially triggering a modal managed by `AppViewModel` or presenting its own), and navigating to other sections like Settings or Trash.
*   **3.4. `WorkspaceViewModel`:**
    *   **Responsibility:** Manages the state and logic for a *single active* workspace displayed in the `WorkspaceContentView`.
        *   Holds the identifier (`id`) of the currently displayed workspace.
        *   Fetches and exposes the workspace's details (e.g., `workspaceName`).
        *   Fetches and manages the chat history (`[ChatMessage]`) for the workspace via `WorkspaceDataManager`.
        *   Holds the user's current input text from the chat input field.
        *   Holds the *latest* generated H5 code (`String`) for the preview, fetched via `WorkspaceDataManager`.
        *   Manages the current view mode state within the content area (e.g., `isChatModeActive`, `isPreviewModeActive`).
        *   Handles the `run` action: takes the user's input, calls `BFFService.sendPrompt(...)`, receives the result, updates the chat history (via `WorkspaceDataManager`), and potentially updates the latest generated code state.
        *   Exposes loading state (`isLoading`) during LLM interaction.
        *   Exposes error messages (`errorMessage`).
        *   Handles actions like `togglePreviewMode`, `copyCode`, `exportCode`, potentially `renameWorkspace`, `deleteWorkspace`, `toggleFavorite`.
*   **3.5. `SettingsViewModel`:**
    *   **Responsibility:** Manages the data and state for the Settings screen. Loads current `AppSettings` using `SettingsManager`. Exposes individual setting values (e.g., `selectedAppearance`) for the View to bind to. Handles user actions to change settings and saves them back using `SettingsManager`.
*   **3.6. `NewWorkspaceModalViewModel`:**
    *   **Responsibility:** Manages the state for the modal dialog used to create a new workspace. Holds the temporary `workspaceName` entered by the user. Handles validation logic for the name input. Executes the creation logic (calling `WorkspaceDataManager.createWorkspace(name:)`) upon confirmation, or dismisses upon cancellation.

**4. View Layer**

This layer is responsible for displaying the UI and capturing user input. In this project, it consists of SwiftUI `View` structs. Views are "dumb" â€“ they bind to data exposed by their corresponding ViewModel, display it, and forward user actions (button taps, text input changes) to the ViewModel.

*   **4.1. `WelcomeView`:**
    *   **Responsibility:** Displays the initial welcome screen elements (buttons for New Workspace, Open Recent, etc.). Binds to `WelcomeViewModel` for actions.
*   **4.2. `MainView`:**
    *   **Responsibility:** Acts as the main container view. Manages the overall layout, including embedding the `SidebarView` and the `WorkspaceContentView` (or other content). Controls the presentation (e.g., sliding animation) of the sidebar based on state from `AppViewModel`.
*   **4.3. `SidebarView`:**
    *   **Responsibility:** Displays the list of workspaces, search bar, section headers, and action buttons (+, Settings). Binds to `SidebarViewModel` to get the lists of workspaces and forwards selection/creation actions.
*   **4.4. `WorkspaceContentView`:**
    *   **Responsibility:** Displays the content for the currently selected workspace. Conditionally displays either `ChatView` or `PreviewView` based on the mode state from `WorkspaceViewModel`. Displays the top bar with workspace name and action icons (Run, Preview, etc.). Forwards actions to `WorkspaceViewModel`.
*   **4.5. `ChatView`:**
    *   **Responsibility:** Displays the scrollable chat history (user prompts and AI responses). Includes the text input field at the bottom. Binds to `WorkspaceViewModel` for the chat messages and the input text state. Forwards the "Run" action (or text submission) to the `WorkspaceViewModel`.
*   **4.6. `PreviewView`:**
    *   **Responsibility:** Contains the `WKWebView` component. Binds to the `WorkspaceViewModel` to get the latest H5 code string and instructs the `WKWebView` to load it. May contain buttons like "Copy Code" or "Export", forwarding actions to `WorkspaceViewModel`.
*   **4.7. `SettingsView`:**
    *   **Responsibility:** Displays the list of settings options (Appearance, etc.). Binds to `SettingsViewModel` to display current values and forwards changes made by the user.
*   **4.8. `NewWorkspaceModalView`:**
    *   **Responsibility:** Displays the modal interface for entering a new workspace name (text field, Create/Cancel buttons). Binds to `NewWorkspaceModalViewModel` for the name input state and forwards confirmation/cancellation actions.

**5. Data Flow Summary**

1.  **User Interaction:** User interacts with a `View` (e.g., taps "Run" button in `ChatView`).
2.  **Action Forwarding:** The `View` calls a corresponding action method on its `ViewModel` (e.g., `workspaceViewModel.runGeneration()`).
3.  **ViewModel Logic:** The `ViewModel` performs logic, potentially updating its own state (e.g., `isLoading = true`). It interacts with `Model` layer Services (e.g., calls `bffService.sendPrompt(...)` or `workspaceDataManager.saveChatMessage(...)`).
4.  **Service Interaction:** Services perform their tasks (network call, database operation).
5.  **Data Return:** Services return data (or errors) back to the `ViewModel` (often asynchronously, e.g., via Combine Publishers).
6.  **ViewModel Update:** The `ViewModel` processes the returned data, updates its state properties (e.g., `chatMessages`, `latestH5Code`, `isLoading = false`).
7.  **View Update:** The `View`, bound to the `ViewModel`'s state properties (e.g., via `@StateObject`, `@ObservedObject`, and `@Published`), automatically re-renders to reflect the changes.

This structure ensures clear separation of concerns, facilitating development, testing, and future modifications of the QuickGen application.